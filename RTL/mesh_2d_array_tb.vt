
`timescale 1ns/1ps

module mesh_2d_array_tb;

    parameter DW     = 8;
    parameter ROWS   = 2;
    parameter COLS   = 4;
    parameter ROW_W  = 1;
    parameter COL_W  = 2;

    reg clk;
    reg rst_n;

    // Config bus
    reg cfg_valid;
    reg [ROW_W + COL_W - 1:0] cfg_addr;
    reg [DW-1:0] cfg_data;

    // FSM signals
    reg [1:0] global_state;
    reg [4:0] cycle;

    // Input vector (flattened)
    reg [COLS*DW-1:0] x_vector_flat;

    // Output result (flattened)
    wire [ROWS*2*DW-1:0] result_flat; 

    // Instantiate the DUT
    mesh_2d_array #(
        .DW(DW),
        .ROWS(ROWS),
        .COLS(COLS),
        .ROW_W(ROW_W),
        .COL_W(COL_W)
    ) dut (
        .clk(clk),
        .rst_n(rst_n),
        .x_vector_flat(x_vector_flat),
        .global_state(global_state), 
        .cfg_valid(cfg_valid),
        .cfg_addr(cfg_addr),
        .cfg_data(cfg_data),
        .result_flat(result_flat) 
    );

    // Clock generation
    always #5 clk = ~clk;

        integer r, c, i;
    initial begin
        $display("Starting 2D Mesh Array Testbench");

        clk = 0;
        rst_n = 0;
        global_state = 2'd0;
        cycle = 0;
        cfg_valid = 0;
        cfg_addr = 0;
        cfg_data = 0;
        x_vector_flat = 0;

        // Reset
        #20 rst_n = 1;

        // Preload weights: weight = row + col
        for (r = 0; r < ROWS; r = r + 1) begin
            for (c = 0; c < COLS; c = c + 1) begin
                @(posedge clk);
                cfg_valid <= 1;
                cfg_addr  <= {r[ROW_W-1:0], c[COL_W-1:0]};
                cfg_data  <= r + c + 1; // example weights
            end
        end
        @(posedge clk);
        cfg_valid <= 0;

        // Provide input vector X = {1, 2, 3, 4}
        x_vector_flat = {8'd4, 8'd3, 8'd2, 8'd1}; // MSB = row3, LSB = row0

        // FSM phase: S_LOAD_X (2'd1)
        global_state <= 2'd1;
        for (cycle = 1; cycle <= ROWS; cycle = cycle + 1) begin
            @(posedge clk);
        end

        // FSM phase: S_MAC (2'd2)
        global_state <= 2'd2;
        for (; cycle <= ROWS + COLS; cycle = cycle + 1) begin
            @(posedge clk);
        end

        // FSM phase: S_STORE (2'd3)
        global_state <= 2'd3;
        cycle <= ROWS + COLS+1;
        @(posedge clk);

        // Display results
        $display("---- Final Mesh Output ----");
        for (i = 0; i < ROWS; i = i + 1) begin 
                $display("Row %0d Result = %0d", i, result_flat[(i+1)*2*DW-1 -: 2*DW]);
            
        end

        $stop;
    end

endmodule
